# 文件建议刷新机制优化

**日期:** 2025-12-08

## 背景

在 `src/ui/useFileSuggestion.ts` 中，`loadPaths` 函数在首次加载后就不会再重新获取文件列表。这导致当用户在首次加载后新增文件时，这些新文件无法出现在 `@` 触发的文件建议列表中。

当前的缓存时间设置为 `600000000000` 毫秒（约 19 年），实际上等于只加载一次，完全没有刷新机制。

**用户需求：** 当输入 `@` 且查询为空时，能够重新获取文件列表，从而解决新增文件获取不到的问题。

## 讨论过程

### 触发时机选择

探讨了以下几种触发时机方案：

- **方案 A：** 每次输入 `@` 时都重新加载
- **方案 B：** 仅当 `@` 后的查询从有内容变为空时重新加载（如 `@abc` → `@`）
- **方案 C：** 每次 `@` 后查询为空且显示建议列表时重新加载

**选择结果：方案 B**

**理由：**
- 性能更优：只在必要时触发加载，避免频繁的文件系统扫描
- 用户意图明确：从 `@abc` 删除到 `@` 时，通常是想重新选择文件
- 避免重复请求：不会因为光标移动、界面刷新等导致重复加载

### 缓存策略选择

在"查询变空触发刷新"的基础上，探讨了缓存策略：

- **方案 A：** 完全移除时间限制，仅依赖"查询变空"触发
- **方案 B：** 保留合理的缓存时间（30-60 秒）
- **方案 C：** 双重机制 - 短缓存 + 查询变空强制刷新

**选择结果：方案 C**

**理由：**
- 正常情况下有 30-60 秒缓存，避免频繁扫描文件系统
- "查询变为空"时无视缓存，强制刷新，满足用户获取新文件的需求
- 最灵活，平衡了性能和数据新鲜度

### 实现方案选择

探讨了三种不同的架构方案：

**方案 1：最小改动**
- 在 `loadPaths` 添加 `forceReload` 参数
- 在 `useFileSuggestion` 中用 `useRef` 追踪 `query` 变化
- 复杂度：⭐⭐

**方案 2：状态提升**
- `usePaths` 接受 `query` 作为参数
- 内部使用 `useEffect` 监听 query 变化，自动处理刷新
- 逻辑封装更好，关注点分离
- 复杂度：⭐⭐

**方案 3：混合方案**
- `usePaths` 提供多个方法（`loadPaths`、`refreshIfNeeded`）
- 职责分明，扩展性好
- 复杂度：⭐⭐⭐

**选择结果：方案 2**

**理由：**
- 逻辑封装在 `usePaths` 内，关注点分离更好
- `useFileSuggestion` 保持简洁
- 复杂度适中，易于维护

## 解决方案

### 核心策略

实现双重刷新机制：

1. **查询变空强制刷新：** 当 `@` 后的查询从非空变为空字符串时（如 `@abc` → `@`），无视缓存时间，强制重新加载文件列表
2. **缓存过期自动刷新：** 当距离上次加载超过 60 秒时，允许重新加载
3. **避免重复加载：** 如果上述条件都不满足，复用已加载的数据

### 实现要点

**修改文件：** `src/ui/useFileSuggestion.ts`

**主要变更：**

1. **`usePaths` Hook 改造**
   - 接受新参数 `query: string`，用于检测查询变化
   - 新增 `prevQueryRef` 用于追踪上一次的查询值
   - 缓存时间从 `600000000000` 改为 `60000`（60秒）

2. **`loadPaths` 函数优化**
   - 接受可选的 `forceReload` 参数
   - 当 `forceReload = true` 时，跳过时间检查
   - 当缓存未过期且非强制刷新时，直接返回
   - 添加 `isLoading` 检查，防止并发请求

3. **新增 useEffect 监听 query 变化**
   ```typescript
   useEffect(() => {
     // 检测条件：上一次查询非空 && 当前查询为空 && hasQuery 为 true
     if (prevQueryRef.current !== '' && query === '' && hasQuery) {
       loadPaths(true); // 强制刷新
     }
     prevQueryRef.current = query;
   }, [query, hasQuery]);
   ```

4. **`useFileSuggestion` 调整**
   - 修改调用：`const { paths, isLoading, loadPaths } = usePaths(query)`
   - 移除现有的 `useEffect([hasQuery, query])`，刷新逻辑已在 `usePaths` 内部处理

## 架构设计

### 数据流

```
用户输入 → InputState 更新 
         ↓
useAtTriggeredPaths 解析 → 提取 query
         ↓
usePaths(query) 接收
         ↓
useEffect 检测变化
         ↓
判断：prevQuery !== '' && query === '' ?
         ↓
   是 → loadPaths(true) 强制刷新
         ↓
   否 → 检查缓存时间
         ↓
      过期 → loadPaths(false) 正常加载
      未过期 → 复用 paths
         ↓
返回 paths 给 useFileSuggestion
         ↓
matchedPaths 计算并展示
```

### 状态管理

**关键状态：**

1. **`prevQueryRef`** - 追踪上一次的查询值
   - 更新时机：每次 useEffect 执行后
   - 用途：检测"查询变为空"的状态

2. **`lastLoadTime`** - 最后加载时间戳
   - 更新时机：只在加载成功后
   - 用途：实现缓存机制

3. **`isLoading`** - 加载状态
   - 用途：防止并发请求，提供 UI 反馈

4. **`paths`** - 文件路径列表
   - 更新时机：只在请求成功后
   - 失败时保留旧数据，不清空

### 边界情况处理

1. **多个 @ 符号**
   - 基于光标位置确定活跃的 query
   - 只有当前光标所在的 query 从有内容变为空时才触发刷新
   - 现有逻辑已支持

2. **快速删除/输入**
   - 通过 `isLoading` 状态防止并发请求
   - 在 `loadPaths` 开始时检查，如果正在加载则直接返回

3. **Tab 触发场景**
   - Tab 触发也会产生 query，但不应触发刷新
   - 只在 `hasQuery && triggerType === 'at'` 时才传递 query 给 usePaths

4. **组件卸载**
   - 需要在 useEffect 中返回清理函数
   - 避免内存泄漏

5. **错误处理**
   - 保持现有的 catch 逻辑
   - 加载失败时不更新 `lastLoadTime`，允许下次重试

## 测试场景

### 基础功能
- 首次输入 `@` 时加载文件列表
- 输入 `@abc` 过滤结果
- 删除变为 `@` 时重新加载

### 缓存机制
- 60秒内多次 `@` 使用缓存
- 超过60秒后重新加载
- 查询变空时无视缓存强制刷新

### 边界场景
- 快速输入删除不触发多次请求
- 多个 `@` 符号只刷新当前活跃的
- Tab 触发不影响 @ 的刷新逻辑

### 错误场景
- 加载失败后能够重试
- 组件卸载不导致内存泄漏

## 预期效果

- ✅ 新增文件后，删除查询变为 `@` 可获取到新文件
- ✅ 短时间内多次使用有缓存，性能良好
- ✅ 长时间后自动刷新，数据保持新鲜
- ✅ 避免频繁的文件系统扫描
- ✅ 用户体验流畅，响应及时
